<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="三、DOM编程对DOM操作代价昂贵，是网页应用中的一个性能瓶颈，这章讨论可能对程序响应造成负面影响的DOM编程，并给出提高响应速度的建议。本章讨论三类问题：
修改和访问DOM元素
修改DOM元素样式，造成重绘和重新排版
通过DOM事件处理用户响应

天生就慢DOM编程天生就很慢，这是因为功能接口连接"/>
    

    <!--Author-->
    
        <meta name="author" content="ldq"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="《高性能Javascript》阅读笔记（二）"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="三、DOM编程对DOM操作代价昂贵，是网页应用中的一个性能瓶颈，这章讨论可能对程序响应造成负面影响的DOM编程，并给出提高响应速度的建议。本章讨论三类问题：
修改和访问DOM元素
修改DOM元素样式，造成重绘和重新排版
通过DOM事件处理用户响应

天生就慢DOM编程天生就很慢，这是因为功能接口连接"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="腊肠的博客"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>《高性能Javascript》阅读笔记（二） - 腊肠的博客</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">首页</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/ldqUndefined">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>《高性能Javascript》阅读笔记（二）</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2018-08-16
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/Javascript/">#Javascript</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h2 id="三、DOM编程"><a href="#三、DOM编程" class="headerlink" title="三、DOM编程"></a>三、DOM编程</h2><h5 id="对DOM操作代价昂贵，是网页应用中的一个性能瓶颈，这章讨论可能对程序响应造成负面影响的DOM编程，并给出提高响应速度的建议。本章讨论三类问题："><a href="#对DOM操作代价昂贵，是网页应用中的一个性能瓶颈，这章讨论可能对程序响应造成负面影响的DOM编程，并给出提高响应速度的建议。本章讨论三类问题：" class="headerlink" title="对DOM操作代价昂贵，是网页应用中的一个性能瓶颈，这章讨论可能对程序响应造成负面影响的DOM编程，并给出提高响应速度的建议。本章讨论三类问题："></a>对DOM操作代价昂贵，是网页应用中的一个性能瓶颈，这章讨论可能对程序响应造成负面影响的DOM编程，并给出提高响应速度的建议。本章讨论三类问题：</h5><ol>
<li><h6 id="修改和访问DOM元素"><a href="#修改和访问DOM元素" class="headerlink" title="修改和访问DOM元素"></a>修改和访问DOM元素</h6></li>
<li><h6 id="修改DOM元素样式，造成重绘和重新排版"><a href="#修改DOM元素样式，造成重绘和重新排版" class="headerlink" title="修改DOM元素样式，造成重绘和重新排版"></a>修改DOM元素样式，造成重绘和重新排版</h6></li>
<li><h6 id="通过DOM事件处理用户响应"><a href="#通过DOM事件处理用户响应" class="headerlink" title="通过DOM事件处理用户响应"></a>通过DOM事件处理用户响应</h6></li>
</ol>
<h5 id="天生就慢"><a href="#天生就慢" class="headerlink" title="天生就慢"></a>天生就慢</h5><p>DOM编程天生就很慢，这是因为功能接口连接带来的性能损耗。把DOM看成岛屿，把Javascript看成另一个岛屿，两者之间以一座收费桥连接，每次JS访问DOM时都要过桥，交一次“过桥费”，操作DOM越多，费用越高。一般建议是尽量减少过桥次数，以减少费用</p>
<h5 id="DOM访问和修改"><a href="#DOM访问和修改" class="headerlink" title="DOM访问和修改"></a>DOM访问和修改</h5><p>访问DOM元素的代价高，修改DOM元素的代价可能更高，因为它经常导致浏览器重新计算页面的几何变化。访问或修改DOM元素最坏的情况就是使用循环执行操作，特别是在HTML几何中使用循环。考虑下面例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function innerHTMLLoop()&#123;</span><br><span class="line">    for(var count = 0;count &lt; 15000; count ++)&#123;</span><br><span class="line">        document.getElementById(&apos;here&apos;).innerHTML += &apos;a&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数在循环中更新页面内容。它的问题在于，每次循环都对DOM元素访问两次：一次读取innerHTML属性内容，另一次写入它</p>
<p>一个更有效率的版本将使用局部变量存储更新后的内容，在循环结束时一次性写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function innerHTMLLoop2()&#123;</span><br><span class="line">    var content=&apos;&apos;;</span><br><span class="line">    for(var count=0;count&lt;15000;count++)&#123;</span><br><span class="line">        content += &apos;a&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(&apos;here&apos;).innerHTML += content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有浏览器中，改写后的版本运行都要快的多。你访问DOM越多，代码执行速度就越慢，因此一般的经验法则是：尽可能少地触摸DOM</p>
<h5 id="innerHTML与DOM方法比较"><a href="#innerHTML与DOM方法比较" class="headerlink" title="innerHTML与DOM方法比较"></a>innerHTML与DOM方法比较</h5><p>更新页面的时候，是使用虽不标准但却被料号支持的innerHTML属性好还是使用纯DOM方法，如document.createElement()更好呢？不考虑其他问题的话它们的性能如何？答案是：性能差别不大。单是在所有浏览器中，innerHTML速度更快一点，除了最新的基于WebKit的浏览器。</p>
<p>书上举了一个例子来说明：用两种方法来创建一个1000行的表</p>
<ol>
<li><h6 id="通过构造一个HTML字符串，然后更新DOM的innerHTML属性"><a href="#通过构造一个HTML字符串，然后更新DOM的innerHTML属性" class="headerlink" title="通过构造一个HTML字符串，然后更新DOM的innerHTML属性"></a>通过构造一个HTML字符串，然后更新DOM的innerHTML属性</h6></li>
<li><h6 id="通过标准DOM方法document-createElement-document-createTextNode"><a href="#通过标准DOM方法document-createElement-document-createTextNode" class="headerlink" title="通过标准DOM方法document.createElement () document.createTextNode()"></a>通过标准DOM方法document.createElement () document.createTextNode()</h6></li>
</ol>
<p>使用innerHTML创建表的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function tableInnerHTML() &#123;</span><br><span class="line">    var i, h = [&apos;&lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;&apos;];</span><br><span class="line">    h.push(&apos;&lt;thead&gt;&apos;);</span><br><span class="line">    h.push(&apos;&lt;tr&gt;&lt;th&gt;id&lt;\/th&gt;&lt;th&gt;yes?&lt;\/th&gt;&lt;th&gt;name&lt;\/th&gt;&lt;th&gt;url&lt;\/th&gt;&lt;th&gt;action&lt;\/th&gt;&lt;\/tr&gt;&apos;);</span><br><span class="line">    h.push(&apos;&lt;\/thead&gt;&apos;);</span><br><span class="line">    h.push(&apos;&lt;tbody&gt;&apos;);</span><br><span class="line">    for (i = 1; i &lt;= 1000; i++) &#123;</span><br><span class="line">        h.push(&apos;&lt;tr&gt;&lt;td&gt;&apos;);</span><br><span class="line">        h.push(i);</span><br><span class="line">        h.push(&apos;&lt;\/td&gt;&lt;td&gt;&apos;);</span><br><span class="line">        h.push(&apos;And the answer is... &apos; + (i % 2 ? &apos;yes&apos; : &apos;no&apos;));</span><br><span class="line">        h.push(&apos;&lt;\/td&gt;&lt;td&gt;&apos;);</span><br><span class="line">        h.push(&apos;my name is #&apos; + i);</span><br><span class="line">        h.push(&apos;&lt;\/td&gt;&lt;td&gt;&apos;);</span><br><span class="line">        h.push(&apos;&lt;a href=&quot;http://example.org/&apos; + i + &apos;.html&quot;&gt;http://example.org/&apos; + i + &apos;.html&lt;\/a&gt;&apos;);</span><br><span class="line">        h.push(&apos;&lt;\/td&gt;&lt;td&gt;&apos;);</span><br><span class="line">        h.push(&apos;&lt;ul&gt;&apos;);</span><br><span class="line">        h.push(&apos; &lt;li&gt;&lt;a href=&quot;edit.php?id=&apos; + i + &apos;&quot;&gt;edit&lt;\/a&gt;&lt;\/li&gt;&apos;);</span><br><span class="line">        h.push(&apos; &lt;li&gt;&lt;a href=&quot;delete.php?id=&quot;&apos; + i + &apos;-id001&quot;&gt;delete&lt;\/a&gt;&lt;\/li&gt;&apos;);</span><br><span class="line">        h.push(&apos;&lt;\/ul&gt;&apos;);</span><br><span class="line">        h.push(&apos;&lt;\/td&gt;&apos;);</span><br><span class="line">        h.push(&apos;&lt;\/tr&gt;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    h.push(&apos;&lt;\/tbody&gt;&apos;);</span><br><span class="line">    h.push(&apos;&lt;\/table&gt;&apos;);</span><br><span class="line">    document.getElementById(&apos;here&apos;).innerHTML = h.join(&apos;&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用DOM方法来创建同样的表，代码有些冗长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">function tableDOM() &#123;</span><br><span class="line">    var i, table, thead, tbody, tr, th, td, a, ul, li;</span><br><span class="line">    tbody = document.createElement (&apos;tbody&apos;);</span><br><span class="line">    for (i = 1; i &lt;= 1000; i++) &#123;</span><br><span class="line">        tr = document.createElement (&apos;tr&apos;);</span><br><span class="line">        td = document.createElement (&apos;td&apos;);</span><br><span class="line">        td.appendChild(document.createTextNode((i % 2) ? &apos;yes&apos; : &apos;no&apos;));</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">        td = document.createElement (&apos;td&apos;);</span><br><span class="line">        td.appendChild(document.createTextNode(i));</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">        td = document.createElement (&apos;td&apos;);</span><br><span class="line">        td.appendChild(document.createTextNode(&apos;my name is #&apos; + i));</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">        a = document.createElement (&apos;a&apos;);</span><br><span class="line">        a.setAttribute(&apos;href&apos;, &apos;http://example.org/&apos; + i + &apos;.html&apos;);</span><br><span class="line">        a.appendChild(document.createTextNode(&apos;http://example.org/&apos; + i + &apos;.html&apos;));</span><br><span class="line">        td = document.createElement (&apos;td&apos;);</span><br><span class="line">        td.appendChild(a);</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">        ul = document.createElement (&apos;ul&apos;);</span><br><span class="line">        a = document.createElement (&apos;a&apos;);</span><br><span class="line">        a.setAttribute(&apos;href&apos;, &apos;edit.php?id=&apos; + i);</span><br><span class="line">        a.appendChild(document.createTextNode(&apos;edit&apos;));</span><br><span class="line">        li = document.createElement (&apos;li&apos;);</span><br><span class="line">        li.appendChild(a);</span><br><span class="line">        ul.appendChild(li);</span><br><span class="line">        a = document.createElement (&apos;a&apos;);</span><br><span class="line">        a.setAttribute(&apos;href&apos;, &apos;delete.php?id=&apos; + i);</span><br><span class="line">        a.appendChild(document.createTextNode(&apos;delete&apos;));</span><br><span class="line">        li = document.createElement (&apos;li&apos;);</span><br><span class="line">        li.appendChild(a);</span><br><span class="line">        ul.appendChild(li);</span><br><span class="line">        td = document.createElement (&apos;td&apos;);</span><br><span class="line">        td.appendChild(ul);</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">        tbody.appendChild(tr);</span><br><span class="line">    &#125;</span><br><span class="line">    tr = document.createElement (&apos;tr&apos;);</span><br><span class="line">    th = document.createElement (&apos;th&apos;);</span><br><span class="line">    th.appendChild(document.createTextNode(&apos;yes?&apos;));</span><br><span class="line">    tr.appendChild(th);</span><br><span class="line">    th = document.createElement (&apos;th&apos;);</span><br><span class="line">    th.appendChild(document.createTextNode(&apos;id&apos;));</span><br><span class="line">    tr.appendChild(th);</span><br><span class="line">    th = document.createElement (&apos;th&apos;);</span><br><span class="line">    th.appendChild(document.createTextNode(&apos;name&apos;));</span><br><span class="line">    tr.appendChild(th);</span><br><span class="line">    th = document.createElement(&apos;th&apos;);</span><br><span class="line">    th.appendChild(document.createTextNode(&apos;url&apos;));</span><br><span class="line">    tr.appendChild(th);</span><br><span class="line">    th = document.createElement(&apos;th&apos;);</span><br><span class="line">    th.appendChild(document.createTextNode(&apos;action&apos;));</span><br><span class="line">    tr.appendChild(th);</span><br><span class="line">    thead = document.createElement(&apos;thead&apos;);</span><br><span class="line">    thead.appendChild(tr);</span><br><span class="line">    table = document.createElement(&apos;table&apos;);</span><br><span class="line">    table.setAttribute(&apos;border&apos;, 1);</span><br><span class="line">    table.setAttribute(&apos;width&apos;, &apos;100%&apos;);</span><br><span class="line">    table.appendChild(thead);</span><br><span class="line">    table.appendChild(tbody);</span><br><span class="line">    document.getElementById(&apos;here&apos;).appendChild(table);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用innerHTML和纯DOM方法穿件HTML表的比较结果如下图所示：</p>
<p><img src="/2018/08/16/javascriptHP2/1.PNG" alt="image"></p>
<p>可以看出性能相差不是特别大，因此决定采用哪种方法将取决于用户经常使用的浏览器和编码偏好。如果在一个性能苛刻的操作中更新一大块HTML页面，innerHTML在大多数浏览器中执行更快。</p>
<h5 id="节点克隆"><a href="#节点克隆" class="headerlink" title="节点克隆"></a>节点克隆</h5><p>使用DOM方法更新页面的另一个途径是克隆已有DOM元素，而不是创建新的—即使用element.cloneNode()代替document.createElement();在大多数浏览器上，克隆节点更有效率，但是提高不太多，下面是使用element.cloneNode()创建表的部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function tableClonedDOM() &#123;</span><br><span class="line">    var i, table, thead, tbody, tr, th, td, a, ul, li,</span><br><span class="line">    oth = document.createElement(&apos;th&apos;),</span><br><span class="line">    otd = document.createElement(&apos;td&apos;),</span><br><span class="line">    otr = document.createElement(&apos;tr&apos;),</span><br><span class="line">    oa = document.createElement(&apos;a&apos;),</span><br><span class="line">    oli = document.createElement(&apos;li&apos;),</span><br><span class="line">    oul = document.createElement(&apos;ul&apos;);</span><br><span class="line">    tbody = document.createElement(&apos;tbody&apos;);</span><br><span class="line">    for (i = 1; i &lt;= 1000; i++) &#123;</span><br><span class="line">        tr = otr.cloneNode(false);</span><br><span class="line">        td = otd.cloneNode(false);</span><br><span class="line">        td.appendChild(document.createTextNode((i % 2) ? &apos;yes&apos; : &apos;no&apos;));</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">        td = otd.cloneNode(false);</span><br><span class="line">        td.appendChild(document.createTextNode(i));</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">        td = otd.cloneNode(false);</span><br><span class="line">        td.appendChild(document.createTextNode(&apos;my name is #&apos; + i));</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">        // ... the rest of the loop ...</span><br><span class="line">    &#125;</span><br><span class="line">    // ... the rest of the table generation ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="HTML集合"><a href="#HTML集合" class="headerlink" title="HTML集合"></a>HTML集合</h5><p>HTML集合是用于存放DOM节点引用的类数组对象，下列函数的返回值就是一个集合：</p>
<ul>
<li>document.getElementsByName()</li>
<li>document.getElementsByClassName()</li>
<li>document.getElementsByTagName()</li>
</ul>
<p>下列属性也属于HTML集合</p>
<ul>
<li>document.images</li>
<li>document.links</li>
<li>document.forms</li>
<li>document.forms[0].elements</li>
</ul>
<p>这些方法和属性返回HTMLCollection对象，是一种类似数组的列表。它们不是数组，但是提供了length属性，和数组一样可以用索引访问列表中的元素。</p>
<p>HTML集合实际上在查询文档，当你更新信息时，每次都要重复执行查询操作，列入读取集合中元素的数目，这也是低效率的来源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// an accidentally infinite loop</span><br><span class="line">var alldivs = document.getElementsByTagName_r(&apos;div&apos;);</span><br><span class="line">for (var i = 0; i &lt; alldivs.length; i++) &#123;</span><br><span class="line">    document.body.appendChild(document.createElement(&apos;div&apos;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码看上去知识简单增加页面中div元素数量，但其实是个死循环，因为循环终止条件alldivs.length在每次迭代中都会增加。</p>
<p>像我们之前讨论过的，不建议使用数组的length属性做循环判断条件。访问集合的length比数组还要慢，因为它每次都要重新运行查询过程。下面的函数将一个集合coll拷贝到数组arr中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function toArray(coll) &#123;</span><br><span class="line">    for (var i = 0, a = [], len = coll.length; i &lt; len; i++) &#123;</span><br><span class="line">        a[i] = coll[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置一个集合，把它拷贝到一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var coll = document.getElementsByTagName_r(&apos;div&apos;);</span><br><span class="line">var ar = toArray(coll);</span><br></pre></td></tr></table></figure>
<p>比较下面两个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//slower</span><br><span class="line">function loopCollection() &#123;</span><br><span class="line">    for (var count = 0; count &lt; coll.length; count++) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// faster</span><br><span class="line">function loopCopiedArray() &#123;</span><br><span class="line">    for (var count = 0; count &lt; arr.length; count++) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次迭代访问length属性时，它导致集合器更新，在所有浏览器上都会产生明显的性能损失。优化方法是将集合的length属性缓存到一个变量中，然后在循环判断条件中使用这个变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function loopCacheLengthCollection() &#123;</span><br><span class="line">    var coll = document.getElementsByTagName_r(&apos;div&apos;),</span><br><span class="line">    len = coll.length;</span><br><span class="line">    for (var count = 0; count &lt; len; count++) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="访问集合元素时使用局部变量"><a href="#访问集合元素时使用局部变量" class="headerlink" title="访问集合元素时使用局部变量"></a>访问集合元素时使用局部变量</h5><p>对于DOM访问，如果一个DOM属性或方法被访问一次以上，最好使用一个局部变量缓存这个DOM成员。下面例子中，在循环中访问每个元素的三个属性，优化最好的版本将集合的当前元素存入局部变量。三个版本都缓存了集合的length属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// slow</span><br><span class="line">function collectionGlobal() &#123;</span><br><span class="line">    var coll = document.getElementsByTagName_r(&apos;div&apos;),</span><br><span class="line">    len = coll.length,</span><br><span class="line">    name = &apos;&apos;;</span><br><span class="line">    for (var count = 0; count &lt; len; count++) &#123;</span><br><span class="line">        name = document.getElementsByTagName_r(&apos;div&apos;)[count].nodeName;</span><br><span class="line">        name = document.getElementsByTagName_r(&apos;div&apos;)[count].nodeType;</span><br><span class="line">        name = document.getElementsByTagName_r(&apos;div&apos;)[count].tagName;</span><br><span class="line">    &#125;</span><br><span class="line">    return name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// faster</span><br><span class="line">function collectionLocal() &#123;</span><br><span class="line">    var coll = document.getElementsByTagName_r(&apos;div&apos;),</span><br><span class="line">    len = coll.length,</span><br><span class="line">    name = &apos;&apos;;</span><br><span class="line">    for (var count = 0; count &lt; len; count++) &#123;</span><br><span class="line">        name = coll[count].nodeName;</span><br><span class="line">        name = coll[count].nodeType;</span><br><span class="line">        name = coll[count].tagName;</span><br><span class="line">    &#125;</span><br><span class="line">    return name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// fastest</span><br><span class="line">function collectionNodesLocal() &#123;</span><br><span class="line">    var coll = document.getElementsByTagName_r(&apos;div&apos;),</span><br><span class="line">    len = coll.length,</span><br><span class="line">    name = &apos;&apos;,</span><br><span class="line">    el = null;</span><br><span class="line">    for (var count = 0; count &lt; len; count++) &#123;</span><br><span class="line">        el = coll[count];</span><br><span class="line">        name = el.nodeName;</span><br><span class="line">        name = el.nodeType;</span><br><span class="line">        name = el.tagName;</span><br><span class="line">    &#125;</span><br><span class="line">    return name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="抓取DOM"><a href="#抓取DOM" class="headerlink" title="抓取DOM"></a>抓取DOM</h5><p>经常需要从一个DOM元素开始操作周围元素，或者递归迭代所有子节点。可以用childNode结合或者使用nextSibling获得每个元素的兄弟节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function testNextSibling() &#123;</span><br><span class="line">    var el = document.getElementById(&apos;mydiv&apos;),</span><br><span class="line">    ch = el.firstChild,</span><br><span class="line">    name = &apos;&apos;;</span><br><span class="line">    do &#123;</span><br><span class="line">        name = ch.nodeName;</span><br><span class="line">    &#125; while (ch = ch.nextSibling);</span><br><span class="line">    return name;</span><br><span class="line">&#125;;</span><br><span class="line">function testChildNodes() &#123;</span><br><span class="line">    var el = document.getElementById(&apos;mydiv&apos;),</span><br><span class="line">    ch = el.childNodes,</span><br><span class="line">    len = ch.length,</span><br><span class="line">    name = &apos;&apos;;</span><br><span class="line">    for (var count = 0; count &lt; len; count++) &#123;</span><br><span class="line">        name = ch[count].nodeName;</span><br><span class="line">    &#125;</span><br><span class="line">    return name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在不同浏览器上着两种方法运行时间基本相等，但在IE中nextSibling表现比childNode快的多。</p>
<h5 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h5><p>DOM属性诸如childNode，firstChild不区分元素节点和其他类型节点。很多情况下只有元素节点需要被访问，所以在循环中，还要对节点返回类型检查，过滤出非元素节点，这些检查和过滤操作都事非必要的DOM操作，现代浏览器提供了API函数值返回元素节点，所以最好利用起来。</p>
<p><img src="/2018/08/16/javascriptHP2/2.PNG" alt="image"></p>
<p>如果只需要返回元素节点，左边都比右边快</p>
<h5 id="选择器API"><a href="#选择器API" class="headerlink" title="选择器API"></a>选择器API</h5><p>有时需要根据类名或者其他方式获得元素集合，用getElementByTagName等函数再过滤效率会很低下，浏览器提供了一个名为querySelectorAll()的原声浏览器DOM函数，显然这种方法比使用JS和DOM迭代缩小元素列表方法要快</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elements = document.querySelectorAll(&apos;#menu a&apos;);</span><br></pre></td></tr></table></figure>
<p>帮我们选择id为menu的子元素下的a标签的NodeList—由符合条件的节点构成的类数组对象，不返回HTML集合。</p>
<p>下面是不使用querySelectorAll()时的操作，比较冗长且效率较低。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elements = document.getElementById(&apos;menu&apos;).getElementsByTagName_r(&apos;a&apos;);</span><br></pre></td></tr></table></figure>
<h4 id="重绘和重排版"><a href="#重绘和重排版" class="headerlink" title="重绘和重排版"></a>重绘和重排版</h4><p>当浏览器下载完所有HTML标记，JS,CSS,图片之后，它解析文件并创建两个内部数据结构：一棵DOM树，一棵渲染树。</p>
<p>渲染树中为每个需要显示的DOM树节点存放至少一个节点（隐藏DOM元素在渲染树中没有对应节点）。渲染树上的节点称为‘框’或者‘盒’，符合css模型定义，将页面元素看成一个具有填充、边距、边框和位置的盒。一旦DOM树和渲染树构造完毕，浏览器就可以显示（绘制）页面上的元素了。</p>
<p>当DOM改变影响到元素的集合属性（宽高）–例如改变边框宽度或者在段落中添加文字，浏览器需要重新计算元素的集合属性，其他元素集合属性和位置也收到影响。浏览器使渲染树上收到影响的部分失效，然后重构渲染树。这个过程被称作重排版。重排版完成时，浏览器在一个绘制进程中重新绘制屏幕上受影响的部分。</p>
<p>不是所有DOM都会改变影响几何属性，例如改变元素背景不会影响宽高，这种情况下，只需重绘，因为元素布局没发生改变。</p>
<p>重绘和重排版是负担很重的操作，可能会导致页面应用失去响应，所以十分有必要减少这类事情的发生。</p>
<h5 id="重排版时会发生啥"><a href="#重排版时会发生啥" class="headerlink" title="重排版时会发生啥"></a>重排版时会发生啥</h5><p>下列情况会发生重排版：</p>
<ol>
<li><h6 id="添加或者删除可见的DOM元素"><a href="#添加或者删除可见的DOM元素" class="headerlink" title="添加或者删除可见的DOM元素"></a>添加或者删除可见的DOM元素</h6></li>
<li><h6 id="元素位置改变"><a href="#元素位置改变" class="headerlink" title="元素位置改变"></a>元素位置改变</h6></li>
<li><h6 id="元素尺寸改变（边距，填充，边框宽度，高度等属性改变）"><a href="#元素尺寸改变（边距，填充，边框宽度，高度等属性改变）" class="headerlink" title="元素尺寸改变（边距，填充，边框宽度，高度等属性改变）"></a>元素尺寸改变（边距，填充，边框宽度，高度等属性改变）</h6></li>
<li><h6 id="内容改变，例如文本改变或者图片被另一个不同尺寸的代替"><a href="#内容改变，例如文本改变或者图片被另一个不同尺寸的代替" class="headerlink" title="内容改变，例如文本改变或者图片被另一个不同尺寸的代替"></a>内容改变，例如文本改变或者图片被另一个不同尺寸的代替</h6></li>
<li><h6 id="最初的页面渲染"><a href="#最初的页面渲染" class="headerlink" title="最初的页面渲染"></a>最初的页面渲染</h6></li>
<li><h6 id="浏览器窗口改变尺寸"><a href="#浏览器窗口改变尺寸" class="headerlink" title="浏览器窗口改变尺寸"></a>浏览器窗口改变尺寸</h6></li>
<li><h6 id="根据改变的性质，渲染树上一部分需要重新计算。某些改变可导致重排版整个页面：例如当一个滚动条出现时。"><a href="#根据改变的性质，渲染树上一部分需要重新计算。某些改变可导致重排版整个页面：例如当一个滚动条出现时。" class="headerlink" title="根据改变的性质，渲染树上一部分需要重新计算。某些改变可导致重排版整个页面：例如当一个滚动条出现时。"></a>根据改变的性质，渲染树上一部分需要重新计算。某些改变可导致重排版整个页面：例如当一个滚动条出现时。</h6></li>
</ol>
<h5 id="查询并刷新渲染树改变"><a href="#查询并刷新渲染树改变" class="headerlink" title="查询并刷新渲染树改变"></a>查询并刷新渲染树改变</h5><p>因为计算量与每次重排版有关，大多数浏览器通过队列化修改和批量显示优化重排版过程。然后你可能（经常不小心）强迫队列刷新并要求所有计划改变的部分立刻应用。获取布局信息的操作将导致刷新队列动作，这意味着使用了下面这些方法：</p>
<ul>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>
<li>scrollTop, scrollLeft, scrollWidth, scrollHeight</li>
<li>clientTop, clientLeft, clientWidth, clientHeight</li>
<li>getComputedStyle() (currentStyle in IE)</li>
</ul>
<p>布局信息由这些属性和方法返回最新的数据。所以浏览器不得不运行渲染队列中待改变的项目并重新排版以返回正确的值。在改变风格的过程中，最好不要使用前面列出的属性。任何一个访问都将刷新渲染队列，及时你正在获取哪些最近未发生改变的或者与最新的改变无关的布局信息。</p>
<p>下面例子改变风格属性三次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// setting and retrieving styles in succession</span><br><span class="line">var computed,</span><br><span class="line">tmp = &apos;&apos;,</span><br><span class="line">bodystyle = document.body.style;</span><br><span class="line">if (document.body.currentStyle) &#123; // IE, Opera</span><br><span class="line">    computed = document.body.currentStyle;</span><br><span class="line">&#125; else &#123; // W3C</span><br><span class="line">    computed = document.defaultView.getComputedStyle(document.body, &apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// inefficient way of modifying the same property</span><br><span class="line">// and retrieving style information right after</span><br><span class="line">bodystyle.color = &apos;red&apos;;</span><br><span class="line">tmp = computed.backgroundColor;</span><br><span class="line">bodystyle.color = &apos;white&apos;;</span><br><span class="line">tmp = computed.backgroundImage;</span><br><span class="line">bodystyle.color = &apos;green&apos;;</span><br><span class="line">tmp = computed.backgroundAttachment;</span><br></pre></td></tr></table></figure>
<p>body元素前景色改变了3次，每次改变都导入了computed风格，导入属性与颜色改变无关，然而浏览器需要刷新渲染队列并重排版，因为computed的风格被查询而引发。更好的例子是不要在布局信息改变时查询它。如果将computed风格查询代码放到末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bodystyle.color = &apos;red&apos;;</span><br><span class="line">bodystyle.color = &apos;white&apos;;</span><br><span class="line">bodystyle.color = &apos;green&apos;;</span><br><span class="line">tmp = computed.backgroundColor;</span><br><span class="line">tmp = computed.backgroundImage;</span><br><span class="line">tmp = computed.backgroundAttachment;</span><br></pre></td></tr></table></figure>
<p>这个例子运行将更快</p>
<h5 id="批量修改DOM（重要）"><a href="#批量修改DOM（重要）" class="headerlink" title="批量修改DOM（重要）"></a>批量修改DOM（重要）</h5><p>当你需要对DOM元素进行多次修改时，你可以通过以下步骤减少重绘和重排版的次数：</p>
<ol>
<li><h6 id="从文档流中摘除该元素"><a href="#从文档流中摘除该元素" class="headerlink" title="从文档流中摘除该元素"></a>从文档流中摘除该元素</h6></li>
<li><h6 id="对其应用多重改变"><a href="#对其应用多重改变" class="headerlink" title="对其应用多重改变"></a>对其应用多重改变</h6></li>
<li><h6 id="将元素带回文档中"><a href="#将元素带回文档中" class="headerlink" title="将元素带回文档中"></a>将元素带回文档中</h6></li>
</ol>
<p>这个过程引发两次重排版—–第一步引发一次，第三步引发一次。如果忽略了这两个步骤，那么第二步中每次改变都将引发一次重排版。</p>
<p>有三种基本方法可以将DOM从文档中摘除：</p>
<ol>
<li><h6 id="隐藏元素，进行修改，然后显示它"><a href="#隐藏元素，进行修改，然后显示它" class="headerlink" title="隐藏元素，进行修改，然后显示它"></a>隐藏元素，进行修改，然后显示它</h6></li>
<li><h6 id="使用一个文档片段在已存DOM之外创建一个子树，然后将它拷贝到文档中。"><a href="#使用一个文档片段在已存DOM之外创建一个子树，然后将它拷贝到文档中。" class="headerlink" title="使用一个文档片段在已存DOM之外创建一个子树，然后将它拷贝到文档中。"></a>使用一个文档片段在已存DOM之外创建一个子树，然后将它拷贝到文档中。</h6></li>
<li><h6 id="将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素"><a href="#将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素" class="headerlink" title="将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素"></a>将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素</h6></li>
</ol>
<p>考虑下面的链接列表，它需要被更多的信息所更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;mylist&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://phpied.com&quot;&gt;Stoyan&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://julienlecomte.com&quot;&gt;Julien&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>假设要插入下面的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Nicholas&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;http://nczonline.net&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Ross&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;http://techfoolery.com&quot;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>下面是一个通用函数，用于更新数据到指定节点中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function appendDataToElement(appendToElement, data) &#123;</span><br><span class="line">    var a, li;</span><br><span class="line">    for (var i = 0, max = data.length; i &lt; max; i++) &#123;</span><br><span class="line">        a = document.createElement(&apos;a&apos;);</span><br><span class="line">        a.href = data[i].url;</span><br><span class="line">        a.appendChild(document.createTextNode(data[i].name));</span><br><span class="line">        li = document.createElement(&apos;li&apos;);</span><br><span class="line">        li.appendChild(a);</span><br><span class="line">        appendToElement.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将数据更新到列表而不管重排版问题，最简单的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(&apos;mylist&apos;);</span><br><span class="line">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure>
<p>这样的话data队列上每个新条目插到DOM树上都会导致重排版。如前面讨论的，减少重排版的一个方法是通过改变display属性，临时从文档上一处ul元素然后再恢复它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(&apos;mylist&apos;);</span><br><span class="line">ul.style.display = &apos;none&apos;;</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.style.display = &apos;block&apos;;</span><br></pre></td></tr></table></figure>
<p>另一次减少重排版次数的方法是：在文档外面创建并更新一个文档片段，然后将它附加在原始列表上。文档片段是一个轻量级的document对象，它被设计专用于更新、移动节点之类的任务。文档片段一个遍历的语法特性是当你向节点附加一个片段时，实际添加的时文档片段的子节点群，而不是片段自己，下面例子减少一行代码，只引发一次重排版，只触发“存在DOM”一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line">document.getElementById(&apos;mylist&apos;).appendChild(fragment);</span><br></pre></td></tr></table></figure>
<p>第三种方法是创建要更新节点的副本，然后在副本上操作，最后覆盖老节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var old = document.getElementById(&apos;mylist&apos;);</span><br><span class="line">var clone = old.cloneNode(true);</span><br><span class="line">appendDataToElement(clone, data);</span><br><span class="line">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure>
<p>推荐尽可能使用文档片段，因为它涉及最少数量的DOM操作和重排版</p>
<h4 id="事件托管"><a href="#事件托管" class="headerlink" title="事件托管"></a>事件托管</h4><p>当页面中有很多元素且每个元素都有一个或多个事件句柄挂接（如onclick），可能会影响性能。连接句柄是有代价的，浏览器会保存句柄记录，占用更多内存。有一些事件句柄可能在工作结束时都没用上，所以很多工作都是不必要的。</p>
<p>一个简单而优雅的处理DOM事件的技术是事件托管。它基于这样一个事实：事件逐层冒泡总能被父元素捕获。采用事件托管技术之后，只需要在一个包装元素上挂接一个句柄，用于处理子元素发生的所有事件。</p>
<p><img src="/2018/08/16/javascriptHP2/3.PNG" alt="image"></p>
<p>考虑上面的页面结构，当用户点击了“menu #1”链接，点击事件首先被a元素收到，然后它沿着DOM树冒泡，被li元素收到，然后ul，接着是div，一直到文档顶层，甚至window，这使你可以只在父元素上挂一个时间句柄，来接受所有子元素产生的事件通知。</p>
<p>假设你要为途中所显示的文档提供一个AJAX体验，点击链接阻止默认行为，然后发送ajax请求获取内容，不刷新页面。使用事件托管实现此功能，可以在ul单元挂一个监听器，它封装所有链接并监听所有click事件，看看它们是否发自一个链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;menu&apos;).onclick = function(e) &#123;</span><br><span class="line">    // x-browser target</span><br><span class="line">    e = e || window.event;</span><br><span class="line">    var target = e.target || e.srcElement;</span><br><span class="line">    var pageid, hrefparts;</span><br><span class="line">    // only interesed in hrefs</span><br><span class="line">    // exit the function on non-link clicks</span><br><span class="line">    if (target.nodeName !== &apos;A&apos;) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // figure out page ID from the link</span><br><span class="line">    hrefparts = target.href.split(&apos;/&apos;);</span><br><span class="line">    pageid = hrefparts[hrefparts.length - 1];</span><br><span class="line">    pageid = pageid.replace(&apos;.html&apos;, &apos;&apos;);</span><br><span class="line">    // update the page</span><br><span class="line">    ajaxRequest(&apos;xhr.php?page=&apos; + id, updatePageContents);</span><br><span class="line">    // x-browser prevent default action and cancel bubbling</span><br><span class="line">    if (typeof e.preventDefault === &apos;function&apos;) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        e.returnValue = false;</span><br><span class="line">        e.cancelBubble = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码中的跨浏览器部分包括：</p>
<ul>
<li><h6 id="访问事件对象，并判断事件源（目标）"><a href="#访问事件对象，并判断事件源（目标）" class="headerlink" title="访问事件对象，并判断事件源（目标）"></a>访问事件对象，并判断事件源（目标）</h6></li>
<li><h6 id="结束文档树上的冒泡（可选）"><a href="#结束文档树上的冒泡（可选）" class="headerlink" title="结束文档树上的冒泡（可选）"></a>结束文档树上的冒泡（可选）</h6></li>
<li><h6 id="阻止默认动作（可选，在此例中必须）"><a href="#阻止默认动作（可选，在此例中必须）" class="headerlink" title="阻止默认动作（可选，在此例中必须）"></a>阻止默认动作（可选，在此例中必须）</h6></li>
</ul>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/ldqUndefined" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2018 ldq<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>